<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/recommendation_agent/services/collaborative_recommender.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/recommendation_agent/services/collaborative_recommender.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Collaborative Filtering Recommender - User-based collaborative filtering with feedback weighting&#10;&quot;&quot;&quot;&#10;import os&#10;import pandas as pd&#10;from collections import defaultdict&#10;from asgiref.sync import sync_to_async&#10;from django.conf import settings&#10;&#10;# Load job postings CSV for skill data&#10;csv_path = os.path.join(settings.BASE_DIR, 'agent_core', 'data', 'job_postings.csv')&#10;data_jp = pd.read_csv(csv_path, encoding='latin-1')&#10;&#10;# Feedback type weights&#10;FEEDBACK_WEIGHTS = {&#10;    'apply': 1.0,   # Strongest signal&#10;    'like': 0.7,    # Medium signal&#10;    'save': 0.5,    # Neutral signal&#10;    'view': 0.3,    # Weak signal&#10;    'dislike': 0.0  # Negative signal&#10;}&#10;&#10;&#10;def _collaborative_filtering_sync(candidate_id: int, job_ids: list, n: int = 5):&#10;    from apps.recommendation_agent.models import JobFeedback, JobPostings&#10;&#10;    print(f&quot;\n CF Recommendation for Candidate {candidate_id}&quot;)&#10;&#10;    # 1. Build user-job interaction matrix&#10;    interaction_data = _build_interaction_matrix()&#10;    user_jobs, job_users, user_job_weights = interaction_data&#10;&#10;    # Debug: Print interaction matrix stats&#10;    print(f&quot;  Total users with interactions: {len(user_jobs)}&quot;)&#10;    print(f&quot;  Total jobs with interactions: {len(job_users)}&quot;)&#10;&#10;    # 2. Get target user's interactions&#10;    target_user_jobs = user_jobs.get(candidate_id, set())&#10;    if not target_user_jobs:&#10;        print(f&quot;  ⚠️  Candidate {candidate_id} has no interaction history&quot;)&#10;        return []&#10;&#10;    print(f&quot;  Target user interacted with {len(target_user_jobs)} jobs&quot;)&#10;&#10;    # 3. Calculate user similarities&#10;    user_similarities = _calculate_user_similarities(&#10;        candidate_id, target_user_jobs, user_jobs, user_job_weights&#10;    )&#10;&#10;    if not user_similarities:&#10;        print(f&quot;  ⚠️  No similar users found&quot;)&#10;        return []&#10;&#10;    # 4. Filter candidate jobs (not yet interacted)&#10;    candidate_jobs = [job_id for job_id in job_ids if job_id not in target_user_jobs]&#10;    if not candidate_jobs:&#10;        print(f&quot;  ⚠️  User has interacted with all available jobs&quot;)&#10;        return []&#10;&#10;    print(f&quot;  Candidate jobs (not interacted): {len(candidate_jobs)}&quot;)&#10;&#10;    # 5. Calculate scores for candidate jobs&#10;    job_scores = _calculate_job_scores(candidate_jobs, job_users, user_similarities)&#10;&#10;    if not job_scores:&#10;        print(f&quot;  ⚠️  No recommendations found&quot;)&#10;        return []&#10;&#10;    # 6. Sort and get top N&#10;    sorted_jobs = sorted(job_scores.items(), key=lambda x: x[1], reverse=True)[:n]&#10;&#10;    # 7. Format results with job details&#10;    return _format_cf_results(sorted_jobs)&#10;&#10;&#10;def _build_interaction_matrix():&#10;    &quot;&quot;&quot;Build user-job interaction matrices with weights&quot;&quot;&quot;&#10;    from apps.recommendation_agent.models import JobFeedback&#10;&#10;    all_feedbacks = JobFeedback.objects.all()&#10;    user_jobs = defaultdict(set)&#10;    job_users = defaultdict(dict)&#10;    user_job_weights = defaultdict(dict)&#10;&#10;    print(f&quot;  Processing {all_feedbacks.count()} feedback records...&quot;)&#10;&#10;    for fb in all_feedbacks:&#10;        # Convert feedback_type to lowercase for case-insensitive matching&#10;        feedback_type_lower = fb.feedback_type.lower() if fb.feedback_type else ''&#10;        feedback_weight = FEEDBACK_WEIGHTS.get(feedback_type_lower, 0.5)&#10;&#10;        if fb.score is not None and fb.score &gt; 0:&#10;            weighted_score = fb.score * feedback_weight&#10;        else:&#10;            weighted_score = feedback_weight&#10;&#10;        # Skip negative feedback (dislike) from building positive interactions&#10;        if feedback_weight &gt; 0:&#10;            user_jobs[fb.candidate_id].add(fb.job_id)&#10;            job_users[fb.job_id][fb.candidate_id] = weighted_score&#10;            user_job_weights[fb.candidate_id][fb.job_id] = weighted_score&#10;&#10;    return user_jobs, job_users, user_job_weights&#10;&#10;&#10;def _calculate_user_similarities(candidate_id, target_user_jobs, user_jobs, user_job_weights):&#10;    &quot;&quot;&quot;Calculate weighted Jaccard similarity between users&quot;&quot;&quot;&#10;    user_similarities = {}&#10;&#10;    for other_user_id, other_user_jobs in user_jobs.items():&#10;        if other_user_id == candidate_id:&#10;            continue&#10;&#10;        common_jobs = target_user_jobs.intersection(other_user_jobs)&#10;        if not common_jobs:&#10;            continue&#10;&#10;        # Calculate weighted similarity&#10;        common_weight_sum = sum(&#10;            min(&#10;                user_job_weights[candidate_id].get(job_id, 0.5),&#10;                user_job_weights[other_user_id].get(job_id, 0.5)&#10;            )&#10;            for job_id in common_jobs&#10;        )&#10;&#10;        all_jobs = target_user_jobs.union(other_user_jobs)&#10;        all_weight_sum = sum(&#10;            max(&#10;                user_job_weights[candidate_id].get(job_id, 0.0),&#10;                user_job_weights[other_user_id].get(job_id, 0.0)&#10;            )&#10;            for job_id in all_jobs&#10;        )&#10;&#10;        if all_weight_sum &gt; 0:&#10;            similarity = common_weight_sum / all_weight_sum&#10;            user_similarities[other_user_id] = similarity&#10;            print(f&quot;  Similarity with User {other_user_id}: {similarity:.4f}&quot;)&#10;&#10;    return user_similarities&#10;&#10;&#10;def _calculate_job_scores(candidate_jobs, job_users, user_similarities):&#10;    &quot;&quot;&quot;Calculate weighted scores for candidate jobs&quot;&quot;&quot;&#10;    job_scores = {}&#10;&#10;    for job_id in candidate_jobs:&#10;        score = 0.0&#10;        users_with_weights = job_users.get(job_id, {})&#10;&#10;        for user_id, job_weight in users_with_weights.items():&#10;            if user_id in user_similarities:&#10;                contribution = user_similarities[user_id] * job_weight&#10;                score += contribution&#10;&#10;        if score &gt; 0:&#10;            job_scores[job_id] = score&#10;&#10;    return job_scores&#10;&#10;&#10;def _format_cf_results(sorted_jobs):&#10;    &quot;&quot;&quot;Format CF results with job details and normalized scores&quot;&quot;&quot;&#10;    from apps.recommendation_agent.models import JobPostings&#10;&#10;    predicted_job_ids = [job_id for job_id, _ in sorted_jobs]&#10;    jobs = JobPostings.objects.filter(id__in=predicted_job_ids).values(&#10;        'id', 'title', 'description', 'address'&#10;    )&#10;    job_details_map = {job['id']: job for job in jobs}&#10;&#10;    # Normalize scores&#10;    max_raw_score = sorted_jobs[0][1] if sorted_jobs else 1.0&#10;&#10;    detailed_results = []&#10;    for job_id, raw_score in sorted_jobs:&#10;        job_info = job_details_map.get(job_id, {})&#10;        normalized_score = raw_score / max_raw_score if max_raw_score &gt; 0 else 0&#10;&#10;        # Get skills from CSV&#10;        skills = &quot;N/A&quot;&#10;        try:&#10;            job_row = data_jp[data_jp['id'] == job_id]&#10;            if not job_row.empty:&#10;                skills = job_row.iloc[0].get('skills', 'N/A')&#10;        except Exception:&#10;            pass&#10;&#10;        detailed_results.append({&#10;            &quot;job_id&quot;: job_id,&#10;            &quot;title&quot;: job_info.get('title', 'Unknown'),&#10;            &quot;description&quot;: job_info.get('description', '')[:200] + '...' if job_info.get('description', '') else '',&#10;            &quot;skills&quot;: skills,&#10;            &quot;similarity&quot;: round(normalized_score, 4),&#10;            &quot;raw_cf_score&quot;: round(raw_score, 4)&#10;        })&#10;&#10;    return detailed_results&#10;&#10;&#10;async def get_collaborative_filtering_recommendations(candidate_id: int, job_ids: list, model=None, n: int = 5):&#10;    &quot;&quot;&quot;Async wrapper for collaborative filtering&quot;&quot;&quot;&#10;    return await sync_to_async(_collaborative_filtering_sync)(candidate_id, job_ids, n)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Collaborative Filtering Recommender - User-based collaborative filtering with feedback weighting&#10;&quot;&quot;&quot;&#10;import os&#10;import pandas as pd&#10;from collections import defaultdict&#10;from asgiref.sync import sync_to_async&#10;from django.conf import settings&#10;&#10;# Load job postings CSV for skill data&#10;csv_path = os.path.join(settings.BASE_DIR, 'agent_core', 'data', 'job_postings.csv')&#10;data_jp = pd.read_csv(csv_path, encoding='latin-1')&#10;&#10;# Feedback type weights&#10;FEEDBACK_WEIGHTS = {&#10;    'apply': 1.0,   # Strongest signal&#10;    'like': 0.7,    # Medium signal&#10;    'save': 0.5,    # Neutral signal&#10;    'view': 0.3,    # Weak signal&#10;    'dislike': 0.0  # Negative signal&#10;}&#10;&#10;&#10;def _collaborative_filtering_sync(candidate_id: int, job_ids: list, n: int = 5):&#10;    from apps.recommendation_agent.models import JobFeedback, JobPostings&#10;&#10;    print(f&quot;\n CF Recommendation for Candidate {candidate_id}&quot;)&#10;&#10;    # 1. Build user-job interaction matrix&#10;    interaction_data = _build_interaction_matrix()&#10;    user_jobs, job_users, user_job_weights = interaction_data&#10;&#10;    # Debug: Print interaction matrix stats&#10;    print(f&quot;  Total users with interactions: {len(user_jobs)}&quot;)&#10;    print(f&quot;  Total jobs with interactions: {len(job_users)}&quot;)&#10;&#10;    # 2. Get target user's interactions&#10;    target_user_jobs = user_jobs.get(candidate_id, set())&#10;    if not target_user_jobs:&#10;        print(f&quot;  ⚠️  Candidate {candidate_id} has no interaction history&quot;)&#10;        return []&#10;&#10;    print(f&quot;  Target user interacted with {len(target_user_jobs)} jobs&quot;)&#10;&#10;    # 3. Calculate user similarities&#10;    user_similarities = _calculate_user_similarities(&#10;        candidate_id, target_user_jobs, user_jobs, user_job_weights&#10;    )&#10;&#10;    if not user_similarities:&#10;        print(f&quot;  ⚠️  No similar users found&quot;)&#10;        return []&#10;&#10;    # 4. Filter candidate jobs (not yet interacted)&#10;    candidate_jobs = [job_id for job_id in job_ids if job_id not in target_user_jobs]&#10;    if not candidate_jobs:&#10;        print(f&quot;  ⚠️  User has interacted with all available jobs&quot;)&#10;        return []&#10;&#10;    print(f&quot;  Candidate jobs (not interacted): {len(candidate_jobs)}&quot;)&#10;&#10;    # 5. Calculate scores for candidate jobs&#10;    job_scores = _calculate_job_scores(candidate_jobs, job_users, user_similarities)&#10;&#10;    if not job_scores:&#10;        print(f&quot;  ⚠️  No recommendations found&quot;)&#10;        return []&#10;&#10;    # 6. Sort and get top N&#10;    sorted_jobs = sorted(job_scores.items(), key=lambda x: x[1], reverse=True)[:n]&#10;&#10;    # 7. Format results with job details&#10;    return _format_cf_results(sorted_jobs)&#10;&#10;&#10;def _build_interaction_matrix():&#10;    &quot;&quot;&quot;Build user-job interaction matrices with weights&quot;&quot;&quot;&#10;    from apps.recommendation_agent.models import JobFeedback&#10;&#10;    all_feedbacks = JobFeedback.objects.all()&#10;    user_jobs = defaultdict(set)&#10;    job_users = defaultdict(dict)&#10;    user_job_weights = defaultdict(dict)&#10;&#10;    print(f&quot;  Processing {all_feedbacks.count()} feedback records...&quot;)&#10;&#10;    for fb in all_feedbacks:&#10;        # Convert feedback_type to lowercase for case-insensitive matching&#10;        feedback_type_lower = fb.feedback_type.lower() if fb.feedback_type else ''&#10;        feedback_weight = FEEDBACK_WEIGHTS.get(feedback_type_lower, 0.5)&#10;&#10;        if fb.score is not None and fb.score &gt; 0:&#10;            weighted_score = fb.score * feedback_weight&#10;        else:&#10;            weighted_score = feedback_weight&#10;&#10;        # Skip negative feedback (dislike) from building positive interactions&#10;        if feedback_weight &gt; 0:&#10;            user_jobs[fb.candidate_id].add(fb.job_id)&#10;            job_users[fb.job_id][fb.candidate_id] = weighted_score&#10;            user_job_weights[fb.candidate_id][fb.job_id] = weighted_score&#10;&#10;    return user_jobs, job_users, user_job_weights&#10;&#10;&#10;def _calculate_user_similarities(candidate_id, target_user_jobs, user_jobs, user_job_weights):&#10;    &quot;&quot;&quot;Calculate weighted Jaccard similarity between users&quot;&quot;&quot;&#10;    user_similarities = {}&#10;&#10;    for other_user_id, other_user_jobs in user_jobs.items():&#10;        if other_user_id == candidate_id:&#10;            continue&#10;&#10;        common_jobs = target_user_jobs.intersection(other_user_jobs)&#10;        if not common_jobs:&#10;            continue&#10;&#10;        # Calculate weighted similarity&#10;        common_weight_sum = sum(&#10;            min(&#10;                user_job_weights[candidate_id].get(job_id, 0.5),&#10;                user_job_weights[other_user_id].get(job_id, 0.5)&#10;            )&#10;            for job_id in common_jobs&#10;        )&#10;&#10;        all_jobs = target_user_jobs.union(other_user_jobs)&#10;        all_weight_sum = sum(&#10;            max(&#10;                user_job_weights[candidate_id].get(job_id, 0.0),&#10;                user_job_weights[other_user_id].get(job_id, 0.0)&#10;            )&#10;            for job_id in all_jobs&#10;        )&#10;&#10;        if all_weight_sum &gt; 0:&#10;            similarity = common_weight_sum / all_weight_sum&#10;            user_similarities[other_user_id] = similarity&#10;            print(f&quot;  Similarity with User {other_user_id}: {similarity:.4f}&quot;)&#10;&#10;    return user_similarities&#10;&#10;&#10;def _calculate_job_scores(candidate_jobs, job_users, user_similarities):&#10;    &quot;&quot;&quot;Calculate weighted scores for candidate jobs&quot;&quot;&quot;&#10;    job_scores = {}&#10;&#10;    for job_id in candidate_jobs:&#10;        score = 0.0&#10;        users_with_weights = job_users.get(job_id, {})&#10;&#10;        for user_id, job_weight in users_with_weights.items():&#10;            if user_id in user_similarities:&#10;                contribution = user_similarities[user_id] * job_weight&#10;                score += contribution&#10;&#10;        if score &gt; 0:&#10;            job_scores[job_id] = score&#10;&#10;    return job_scores&#10;&#10;&#10;def _format_cf_results(sorted_jobs):&#10;    &quot;&quot;&quot;Format CF results with job details and normalized scores&quot;&quot;&quot;&#10;    from apps.recommendation_agent.models import JobPostings&#10;    from datetime import date&#10;&#10;    predicted_job_ids = [job_id for job_id, _ in sorted_jobs]&#10;    &#10;    # Only get active, non-expired jobs&#10;    today = date.today()&#10;    jobs = JobPostings.objects.filter(&#10;        id__in=predicted_job_ids,&#10;        status=&quot;ACTIVE&quot;,&#10;        expiration_date__gte=today&#10;    ).values(&#10;        'id', 'title', 'description', 'address'&#10;    )&#10;    job_details_map = {job['id']: job for job in jobs}&#10;&#10;    # Normalize scores&#10;    max_raw_score = sorted_jobs[0][1] if sorted_jobs else 1.0&#10;&#10;    detailed_results = []&#10;    for job_id, raw_score in sorted_jobs:&#10;        # Skip if job not found (expired or deleted)&#10;        if job_id not in job_details_map:&#10;            continue&#10;            &#10;        job_info = job_details_map[job_id]&#10;        normalized_score = raw_score / max_raw_score if max_raw_score &gt; 0 else 0&#10;&#10;        # Get skills from CSV&#10;        skills = &quot;N/A&quot;&#10;        try:&#10;            job_row = data_jp[data_jp['id'] == job_id]&#10;            if not job_row.empty:&#10;                skills = job_row.iloc[0].get('skills', 'N/A')&#10;        except Exception:&#10;            pass&#10;&#10;        detailed_results.append({&#10;            &quot;job_id&quot;: job_id,&#10;            &quot;title&quot;: job_info.get('title', 'Unknown'),&#10;            &quot;description&quot;: job_info.get('description', '')[:200] + '...' if job_info.get('description', '') else '',&#10;            &quot;skills&quot;: skills,&#10;            &quot;similarity&quot;: round(normalized_score, 4),&#10;            &quot;raw_cf_score&quot;: round(raw_score, 4)&#10;        })&#10;&#10;    return detailed_results&#10;&#10;&#10;async def get_collaborative_filtering_recommendations(candidate_id: int, job_ids: list, model=None, n: int = 5):&#10;    &quot;&quot;&quot;Async wrapper for collaborative filtering&quot;&quot;&quot;&#10;    return await sync_to_async(_collaborative_filtering_sync)(candidate_id, job_ids, n)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/recommendation_agent/services/job_query_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/recommendation_agent/services/job_query_service.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Job Query Service - Handles database queries for job postings&#10;&quot;&quot;&quot;&#10;from asgiref.sync import sync_to_async&#10;from apps.recommendation_agent.models import JobPostings&#10;&#10;&#10;def _query_all_jobs_sync():&#10;    &quot;&quot;&quot;&#10;    Get ACTIVE jobs from PostgreSQL (ORM)&#10;&#10;    Returns:&#10;        list: List of active job postings&#10;    &quot;&quot;&quot;&#10;    jobs = JobPostings.objects.filter(status=&quot;ACTIVE&quot;).values(&#10;        &quot;id&quot;, &quot;title&quot;, &quot;description&quot;, &quot;address&quot;&#10;    )&#10;&#10;    job_list = [&#10;        {&#10;            &quot;job_id&quot;: job[&quot;id&quot;],&#10;            &quot;title&quot;: job[&quot;title&quot;],&#10;            &quot;description&quot;: job[&quot;description&quot;],&#10;            &quot;address&quot;: job[&quot;address&quot;]&#10;        }&#10;        for job in jobs&#10;    ]&#10;    return job_list&#10;&#10;&#10;def query_all_jobs():&#10;    &quot;&quot;&quot;&#10;    Get active jobs (synchronous wrapper for backward compatibility)&#10;&#10;    Returns:&#10;        list: List of active job postings&#10;    &quot;&quot;&quot;&#10;    return _query_all_jobs_sync()&#10;&#10;&#10;async def query_all_jobs_async():&#10;    &quot;&quot;&quot;&#10;    Get active jobs (async wrapper)&#10;&#10;    Returns:&#10;        list: List of active job postings&#10;    &quot;&quot;&quot;&#10;    return await sync_to_async(_query_all_jobs_sync)()&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#13;&#10;Job Query Service - Handles database queries for job postings&#13;&#10;&quot;&quot;&quot;&#13;&#10;from datetime import date&#13;&#10;from asgiref.sync import sync_to_async&#13;&#10;from apps.recommendation_agent.models import JobPostings&#13;&#10;&#13;&#10;&#13;&#10;def _query_all_jobs_sync():&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Get ACTIVE and non-expired jobs from PostgreSQL (ORM)&#13;&#10;&#13;&#10;    Returns:&#13;&#10;        list: List of active job postings that haven't expired&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    today = date.today()&#13;&#10;    jobs = JobPostings.objects.filter(&#13;&#10;        status=&quot;ACTIVE&quot;,&#13;&#10;        expiration_date__gte=today&#13;&#10;    ).values(&#13;&#10;        &quot;id&quot;, &quot;title&quot;, &quot;description&quot;, &quot;address&quot;&#13;&#10;    )&#13;&#10;&#13;&#10;    job_list = [&#13;&#10;        {&#13;&#10;            &quot;job_id&quot;: job[&quot;id&quot;],&#13;&#10;            &quot;title&quot;: job[&quot;title&quot;],&#13;&#10;            &quot;description&quot;: job[&quot;description&quot;],&#13;&#10;            &quot;address&quot;: job[&quot;address&quot;]&#13;&#10;        }&#13;&#10;        for job in jobs&#13;&#10;    ]&#13;&#10;    return job_list&#13;&#10;&#13;&#10;&#13;&#10;def query_all_jobs():&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Get active and non-expired jobs (synchronous wrapper for backward compatibility)&#13;&#10;&#13;&#10;    Returns:&#13;&#10;        list: List of active job postings that haven't expired&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    return _query_all_jobs_sync()&#13;&#10;&#13;&#10;&#13;&#10;async def query_all_jobs_async():&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Get active and non-expired jobs (async wrapper)&#13;&#10;&#13;&#10;    Returns:&#13;&#10;        list: List of active job postings that haven't expired&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    return await sync_to_async(_query_all_jobs_sync)()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/recommendation_agent/services/job_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/recommendation_agent/services/job_service.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Job Indexing Service for syncing jobs to Weaviate&#10;&quot;&quot;&quot;&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class JobIndexingService:&#10;    &quot;&quot;&quot;Service for indexing jobs to Weaviate&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def sync_single_job_to_weaviate(job_id):&#10;        &quot;&quot;&quot;&#10;        Sync a single job to Weaviate&#10;        &#10;        Args:&#10;            job_id: ID of the job to sync&#10;            &#10;        Returns:&#10;            bool: True if successful, False otherwise&#10;        &quot;&quot;&quot;&#10;        try:&#10;            from ..models import JobPostings, JobDescription&#10;            from .weaviate_service import index_job, delete_job&#10;            &#10;            # Get job from database&#10;            try:&#10;                job = JobPostings.objects.select_related('recruiter').prefetch_related(&#10;                    'jobdescription_set__jd_skill'&#10;                ).get(id=job_id)&#10;            except JobPostings.DoesNotExist:&#10;                logger.warning(f&quot;Job {job_id} not found in database&quot;)&#10;                return False&#10;            &#10;            # If job is not active, remove from Weaviate&#10;            if job.status != 'ACTIVE':&#10;                return delete_job(job_id)&#10;            &#10;            # Prepare job data for indexing&#10;            skills = [jd.jd_skill.name for jd in job.jobdescription_set.all()]&#10;            &#10;            job_data = {&#10;                'job_id': job.id,&#10;                'title': job.title,&#10;                'description': job.description or '',&#10;                'skills': skills,&#10;                'company_name': job.recruiter.company_name,&#10;                'address': job.address or '',&#10;            }&#10;            &#10;            # Index to Weaviate&#10;            return index_job(job_data)&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error syncing job {job_id} to Weaviate: {str(e)}&quot;)&#10;            return False&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/recommendation_agent/services/weaviate_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/recommendation_agent/services/weaviate_service.py" />
              <option name="originalContent" value="import asyncio&#10;&#10;from agent_core.weaviate_config import WeaviateClientManager&#10;&#10;manager = WeaviateClientManager()&#10;client = manager.get_client()&#10;def _query_weaviate_sync(vector, limit):&#10;    &quot;&quot;&quot;Synchronous function to query Weaviate using v4 API with default vector&quot;&quot;&quot;&#10;    # Get the collection&#10;    job_collection = client.collections.get(&quot;JobPosting&quot;)&#10;&#10;    # Query using v4 API with default vector (no target_vector needed)&#10;    response = job_collection.query.near_vector(&#10;        near_vector=vector,&#10;        limit=limit,&#10;        return_metadata=['distance'],&#10;        include_vector=True&#10;    )&#10;&#10;    items = []&#10;    for obj in response.objects:&#10;        skills_field = obj.properties.get(&quot;skills&quot;, [])&#10;        # nếu skills là list, nối thành chuỗi&#10;        if isinstance(skills_field, list):&#10;            skills_text = &quot;, &quot;.join(str(s) for s in skills_field)&#10;        else:&#10;            skills_text = str(skills_field)&#10;&#10;        items.append({&#10;            &quot;job_id&quot;: obj.properties.get(&quot;jobId&quot;),&#10;            &quot;title&quot;: obj.properties.get(&quot;title&quot;),&#10;            &quot;skills&quot;: skills_text,&#10;            &quot;address&quot;: obj.properties.get(&quot;address&quot;),&#10;            &quot;description&quot;: obj.properties.get(&quot;description&quot;),&#10;            &quot;distance&quot;: obj.metadata.distance if obj.metadata else 0,&#10;        })&#10;    return items&#10;&#10;async def query_weaviate_async(vector: list, limit: int = 10):&#10;    &quot;&quot;&quot;Async wrapper to query Weaviate&quot;&quot;&quot;&#10;    loop = asyncio.get_running_loop()&#10;    return await loop.run_in_executor(None, _query_weaviate_sync, vector, limit)&#10;&#10;" />
              <option name="updatedContent" value="import asyncio&#10;from datetime import date&#10;&#10;from agent_core.weaviate_config import WeaviateClientManager&#10;&#10;manager = WeaviateClientManager()&#10;client = manager.get_client()&#10;&#10;def _query_weaviate_sync(vector, limit):&#10;    &quot;&quot;&quot;Synchronous function to query Weaviate using v4 API with default vector&quot;&quot;&quot;&#10;    from apps.recommendation_agent.models import JobPostings&#10;    &#10;    # Get the collection&#10;    job_collection = client.collections.get(&quot;JobPosting&quot;)&#10;&#10;    # Query using v4 API with default vector (no target_vector needed)&#10;    response = job_collection.query.near_vector(&#10;        near_vector=vector,&#10;        limit=limit,&#10;        return_metadata=['distance'],&#10;        include_vector=True&#10;    )&#10;&#10;    # Get valid job IDs (not expired) from database&#10;    today = date.today()&#10;    valid_job_ids = set(&#10;        JobPostings.objects.filter(&#10;            status=&quot;ACTIVE&quot;,&#10;            expiration_date__gte=today&#10;        ).values_list('id', flat=True)&#10;    )&#10;&#10;    items = []&#10;    for obj in response.objects:&#10;        job_id = obj.properties.get(&quot;jobId&quot;)&#10;        &#10;        # Skip expired jobs&#10;        if job_id not in valid_job_ids:&#10;            continue&#10;            &#10;        if len(items) &gt;= limit:&#10;            break&#10;            &#10;        skills_field = obj.properties.get(&quot;skills&quot;, [])&#10;        # nếu skills là list, nối thành chuỗi&#10;        if isinstance(skills_field, list):&#10;            skills_text = &quot;, &quot;.join(str(s) for s in skills_field)&#10;        else:&#10;            skills_text = str(skills_field)&#10;&#10;        items.append({&#10;            &quot;job_id&quot;: job_id,&#10;            &quot;title&quot;: obj.properties.get(&quot;title&quot;),&#10;            &quot;skills&quot;: skills_text,&#10;            &quot;address&quot;: obj.properties.get(&quot;address&quot;),&#10;            &quot;description&quot;: obj.properties.get(&quot;description&quot;),&#10;            &quot;distance&quot;: obj.metadata.distance if obj.metadata else 0,&#10;        })&#10;    return items&#10;&#10;async def query_weaviate_async(vector: list, limit: int = 10):&#10;    &quot;&quot;&quot;Async wrapper to query Weaviate&quot;&quot;&quot;&#10;    loop = asyncio.get_running_loop()&#10;    return await loop.run_in_executor(None, _query_weaviate_sync, vector, limit)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>