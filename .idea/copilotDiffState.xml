<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/recommendation_agent/services/job_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/recommendation_agent/services/job_service.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Job Indexing Service for syncing jobs to Weaviate&#10;&quot;&quot;&quot;&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class JobIndexingService:&#10;    &quot;&quot;&quot;Service for indexing jobs to Weaviate&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def sync_single_job_to_weaviate(job_id):&#10;        &quot;&quot;&quot;&#10;        Sync a single job to Weaviate&#10;        &#10;        Args:&#10;            job_id: ID of the job to sync&#10;            &#10;        Returns:&#10;            bool: True if successful, False otherwise&#10;        &quot;&quot;&quot;&#10;        try:&#10;            from ..models import JobPostings, JobDescription&#10;            from .weaviate_service import index_job, delete_job&#10;            &#10;            # Get job from database&#10;            try:&#10;                job = JobPostings.objects.select_related('recruiter').prefetch_related(&#10;                    'jobdescription_set__jd_skill'&#10;                ).get(id=job_id)&#10;            except JobPostings.DoesNotExist:&#10;                logger.warning(f&quot;Job {job_id} not found in database&quot;)&#10;                return False&#10;            &#10;            # If job is not active, remove from Weaviate&#10;            if job.status != 'ACTIVE':&#10;                return delete_job(job_id)&#10;            &#10;            # Prepare job data for indexing&#10;            skills = [jd.jd_skill.name for jd in job.jobdescription_set.all()]&#10;            &#10;            job_data = {&#10;                'job_id': job.id,&#10;                'title': job.title,&#10;                'description': job.description or '',&#10;                'skills': skills,&#10;                'company_name': job.recruiter.company_name,&#10;                'address': job.address or '',&#10;            }&#10;            &#10;            # Index to Weaviate&#10;            return index_job(job_data)&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Error syncing job {job_id} to Weaviate: {str(e)}&quot;)&#10;            return False&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/recommendation_agent/services/overlap_skill.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/recommendation_agent/services/overlap_skill.py" />
              <option name="originalContent" value="&#10;&#10;def calculate_skill_overlap(query_skills: list, job_skills: list) -&gt; float:&#10;    if not query_skills or not job_skills:&#10;        return 0.0&#10;&#10;    # Normalize skills to lowercase for comparison&#10;    query_skills_normalized = {str(s).lower().strip() for s in query_skills}&#10;    job_skills_normalized = {str(s).lower().strip() for s in job_skills}&#10;&#10;    # Calculate intersection&#10;    overlap = query_skills_normalized.intersection(job_skills_normalized)&#10;&#10;    # Calculate Jaccard similarity: |intersection| / |union|&#10;    union = query_skills_normalized.union(job_skills_normalized)&#10;    jaccard_score = len(overlap) / len(union) if union else 0.0&#10;&#10;    # Also calculate recall: |intersection| / |job_skills|&#10;    # This measures how many of the required job skills the candidate has&#10;    recall_score = len(overlap) / len(job_skills_normalized) if job_skills_normalized else 0.0&#10;&#10;    # Weighted combination (favor recall - having the required skills is more important)&#10;    skill_overlap_score = (0.4 * jaccard_score) + (0.6 * recall_score)&#10;&#10;    return skill_overlap_score&#10;&#10;def calculate_skill_overlap_for_job_recommendation(user_skills: list, job_skills: list) -&gt; float:&#10;    &quot;&quot;&quot;&#10;    Tính độ trùng kỹ năng giữa ứng viên (user) và job.&#10;    - user_skills: kỹ năng ứng viên (query)&#10;    - job_skills: kỹ năng trong job posting&#10;    Trả về giá trị [0, 1].&#10;    &quot;&quot;&quot;&#10;    if not user_skills or not job_skills:&#10;        return 0.0&#10;&#10;    # Chuẩn hóa lowercase&#10;    user = {str(s).lower().strip() for s in user_skills if s}&#10;    job = {str(s).lower().strip() for s in job_skills if s}&#10;&#10;    overlap = user.intersection(job)&#10;    if not overlap:&#10;        return 0.0&#10;&#10;    # Recall: ứng viên cover bao nhiêu % kỹ năng job yêu cầu&#10;    recall_job = len(overlap) / len(job)&#10;    # Precision: bao nhiêu % kỹ năng ứng viên phù hợp job&#10;    recall_user = len(overlap) / len(user)&#10;&#10;    # F1-like score&#10;    f1_like = (2 * recall_job * recall_user) / (recall_job + recall_user)&#10;    return round(f1_like, 3)&#10;&#10;" />
              <option name="updatedContent" value="def calculate_skill_overlap(query_skills: list, job_skills: list) -&gt; float:&#13;&#10;    if not query_skills or not job_skills:&#13;&#10;        return 0.0&#13;&#10;&#13;&#10;    # Normalize skills to lowercase for comparison&#13;&#10;    query_skills_normalized = {str(s).lower().strip() for s in query_skills}&#13;&#10;    job_skills_normalized = {str(s).lower().strip() for s in job_skills}&#13;&#10;&#13;&#10;    # Calculate intersection&#13;&#10;    overlap = query_skills_normalized.intersection(job_skills_normalized)&#13;&#10;&#13;&#10;    # Calculate Jaccard similarity: |intersection| / |union|&#13;&#10;    union = query_skills_normalized.union(job_skills_normalized)&#13;&#10;    jaccard_score = len(overlap) / len(union) if union else 0.0&#13;&#10;&#13;&#10;    # Also calculate recall: |intersection| / |job_skills|&#13;&#10;    # This measures how many of the required job skills the candidate has&#13;&#10;    recall_score = len(overlap) / len(job_skills_normalized) if job_skills_normalized else 0.0&#13;&#10;&#13;&#10;    # Weighted combination (favor recall - having the required skills is more important)&#13;&#10;    skill_overlap_score = (0.4 * jaccard_score) + (0.6 * recall_score)&#13;&#10;&#13;&#10;    return skill_overlap_score&#13;&#10;&#13;&#10;def calculate_skill_overlap_for_job_recommendation(user_skills: list, job_skills: list) -&gt; float:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Tính độ trùng kỹ năng giữa ứng viên (user) và job.&#13;&#10;    - user_skills: kỹ năng ứng viên (query)&#13;&#10;    - job_skills: kỹ năng trong job posting&#13;&#10;    &#13;&#10;    Logic: Chỉ tính recall_job (user có bao nhiêu % skill job yêu cầu)&#13;&#10;    Ứng viên có thêm skill khác KHÔNG bị penalty.&#13;&#10;    &#13;&#10;    Trả về giá trị [0, 1].&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    if not user_skills or not job_skills:&#13;&#10;        return 0.0&#13;&#10;&#13;&#10;    # Chuẩn hóa lowercase&#13;&#10;    user = {str(s).lower().strip() for s in user_skills if s}&#13;&#10;    job = {str(s).lower().strip() for s in job_skills if s}&#13;&#10;&#13;&#10;    overlap = user.intersection(job)&#13;&#10;    if not overlap:&#13;&#10;        return 0.0&#13;&#10;&#13;&#10;    # Chỉ tính recall_job: user cover bao nhiêu % skill job yêu cầu&#13;&#10;    # Nếu job cần [python, pandas] và user có [python, pandas, pytorch]&#13;&#10;    # → 2/2 = 100% (có đủ yêu cầu, pytorch là bonus không bị trừ điểm)&#13;&#10;    recall_job = len(overlap) / len(job)&#13;&#10;    &#13;&#10;    return recall_job" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>